[{"title":"Hello World","url":"/2020/11/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"go-blog系列(1) restful风格接口设计","url":"/2020/11/04/go-blog系列-1-restful风格接口设计/","content":"\n1.  [restful 风格的几大准则](#orgb544a95)\n2.  [给我们的博客设计接口](#org0aacddb)\n3.  [代码](#orgf12b47a)\n\n## restful 风格的几大准则\n\n1.  以json格式接受和返回请求\n2.  使用名词结尾\n    解释:http请求方法已经有POST、DELETE、PUT、GET能分别对应增、删、改、查\n3.  名词用复数形式\n    解释:请求对应的是服务器的一种资源,资源往往都是复数的。如我们的博客文章表,也是命名为articles,而不是article\n4.  使用层级区分资源\n    解释:如我们想要获取评论,应当使用下面这样的形式\n\n> '*articles*:articleId/comments'\n\n​\t因为comments是articles的子级资源\n\n5. 接口应当接受筛选参数、排序和分页\n\n6. 标准化响应请求\n   常用的返回码如下:\n\n* 400 Bad Request – This means that client-side input fails validation.\n* 401 Unauthorized – This means the user isn’t not authorized to access a resource. It usually returns when the user isn’t authenticated.\n* 403 Forbidden – This means the user is authenticated, but it’s not allowed to access a resource.\n* 404 Not Found – This indicates that a resource is not found.\n* 500 Internal server error – This is a generic server error. It probably shouldn’t be thrown explicitly.\n* 502 Bad Gateway – This indicates an invalid response from an upstream server.\n* 503 Service Unavailable – This indicates that something unexpected happened on server side (It can be anything like server overload, some parts of the system failed, etc.).\n\n7. 给接口加上版本号\n   解释:如下形式\n\n> /v1/employees\n\n资料:\n[rest api 博客](https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/)\n\n\n\n\n## 给我们的博客设计接口\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n\n<colgroup>\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n\n<col  class=\"org-left\" />\n</colgroup>\n<tbody>\n<tr>\n<td class=\"org-left\">功能</td>\n<td class=\"org-left\">HTTP方法</td>\n<td class=\"org-left\">路径</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">用户注册</td>\n<td class=\"org-left\">POST</td>\n<td class=\"org-left\">/users</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">用户登录</td>\n<td class=\"org-left\">GET</td>\n<td class=\"org-left\">/tokens</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">用户更新</td>\n<td class=\"org-left\">PUT</td>\n<td class=\"org-left\">*users*:user<sub>id</sub></td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">用户删除</td>\n<td class=\"org-left\">DELETE</td>\n<td class=\"org-left\">*users*:user<sub>id</sub></td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">发表文章</td>\n<td class=\"org-left\">POST</td>\n<td class=\"org-left\">*users*:user<sub>id</sub>/articles</td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">编辑文章</td>\n<td class=\"org-left\">PUT</td>\n<td class=\"org-left\">*users*:user<sub>id</sub>/articles/:article<sub>id</sub></td>\n</tr>\n\n\n<tr>\n<td class=\"org-left\">删除文章</td>\n<td class=\"org-left\">DELETE</td>\n<td class=\"org-left\">*users*:user<sub>id</sub>/articles/:article<sub>id</sub></td>\n</tr>\n</tbody>\n</table>\n\n解释一下用户登录为什么是/tokens;restful风格的接口将请求认为是对服务器资源的访问，而登录实质上是获取token资源的一个过程\n\n\n<a id=\"orgf12b47a\"></a>\n\n## 代码\n\n在项目中新建api/v1目录并新建文件UserService.go,然后写入如下代码\n\n    type UserService struct {\n    }\n    \n    func NewUserService() UserService {\n    \treturn UserService{}\n    }\n    \n    func (userService *UserService) Create(c *gin.Context) {\n    \n    }\n    func (userService *UserService) Login(c *gin.Context) {\n    \n    }\n    func (userService *UserService) Edit(c *gin.Context) {\n    \n    }\n    \n    func (userService *UserService) Delete(c *gin.Context) {\n    \n    }\n    func (userService *UserService) PostArticles(c *gin.Context) {\n    \n    }\n    \n    func (userService *UserService) EditArticles(c *gin.Context) {\n    \n    }\n    func (userService *UserService) DeleteArticles(c *gin.Context) {\n    \n    }\n\n在项目根目录新建main.go,\n在main.go中写入如下代码\n\n    router := gin.Default()\n    \n    //版本号v1\n    v1 := router.Group(\"/v1\")\n    {\n    \tuserService := service.NewUserService()\n    \tv1.POST(\"/users\", userService.Create)\n    \tv1.GET(\"/tokens\", userService.Login)\n    \tv1.PUT(\"/users/:user_id\", userService.Edit)\n    \tv1.DELETE(\"/users/:user_id\", userService.Delete)\n    \tv1.POST(\"/users/:user_id/articles\", userService.PostArticles)\n    \tv1.PUT(\"/users/:user_id/articles/:article_id\", userService.EditArticles)\n    \tv1.DELETE(\"/users/:user_id/articles/:article_id\", userService.DeleteArticles)\n    }\n    \n    router.Run(\":8080\")\n\n完整代码查看我的github项目\n\n    git clone git clone https://github.com/Pissssofshit/go-blog\n\n,并检出分支\n\n    git checkout restfulapi设计\n\n在项目下运行\n\n    go run main.go\n\n项目就会运行在8080端口下\n\n"},{"title":"go-jwt实现api鉴权","url":"/2020/11/03/2020-11-03-go-jwt实现api鉴权/","content":"\n## 什么是jwt\n\njwt是json-web-token的缩写。\n\n### jwt 用法\n\n在用户注册登录后,服务端会生成一个jwt token返回给客户端,客户端后续向服务端请求数据时携带token,服务器端使用sign中定义的方式进行解码，并对token进行解析和验证。\n\n\n\n"},{"title":"go-http源码分析(1)","url":"/2020/11/03/go-http源码分析-1/","content":"\n众所周知go用一行代码就可以实现一个web server,如下\n\n    http.ListenAndServe(\":8080\",nil)\n\n这个ListendAndServe的实现也很简单\n\n    func ListenAndServe(addr string, handler Handler) error {\n    \tserver := &Server{Addr: addr, Handler: handler}\n    \treturn server.ListenAndServe()\n    }\n\naddr好理解，定义了web服务器的ip、端口，那么这个Handler是什么呢？实际上这是一个接口，定义如下\n\n    type Handler interface {\n    \tServeHTTP(ResponseWriter, *Request)\n    }\n\n只有一个方法，就可以实现~\n\n要搞懂它是干嘛的，我们还要再顺着它的调用往下看几个函数，放心，不长\n\n    func (srv *Server) Serve(l net.Listener) error {\n    \n    \t//有删除\n    \n    \torigListener := l\n    \tl = &onceCloseListener{Listener: l}\n    \tdefer l.Close()\n    \n    \t//有删除\n    \n    \tvar tempDelay time.Duration // how long to sleep on accept failure\n    \n    \tctx := context.WithValue(baseCtx, ServerContextKey, srv)\n    \tfor {\n    \t\trw, err := l.Accept()\n    \t\tif err != nil {\n    \t\t//有删除\n    \t\t//错误处理\n    \t\t}\n    \t\tconnCtx := ctx\n    \t\tif cc := srv.ConnContext; cc != nil {\n    \t\t\tconnCtx = cc(connCtx, rw)\n    \t\t\tif connCtx == nil {\n    \t\t\t\tpanic(\"ConnContext returned nil\")\n    \t\t\t}\n    \t\t}\n    \t\ttempDelay = 0\n    \t\tc := srv.newConn(rw)\n    \t\tc.setState(c.rwc, StateNew) // before Serve can return\n    \t\t// 一个连接一个协程，体现了go的高并发\n    \t\tgo c.serve(connCtx)\n    \t}\n    }\n\n再往下看c.serve方法:\n\n    func (c *conn) serve(ctx context.Context) {\n    \tc.remoteAddr = c.rwc.RemoteAddr().String()\n    \tctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())\n    \n    \t//有删除,连接结束清除工作\n    \n    \t//有删除 tls 握手验证\n    \n    \t// HTTP/1.x from here on.\n    \n    \tctx, cancelCtx := context.WithCancel(ctx)\n    \tc.cancelCtx = cancelCtx\n    \tdefer cancelCtx()\n    \n    \tc.r = &connReader{conn: c}\n    \tc.bufr = newBufioReader(c.r)\n    \tc.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10)\n    \n    \tfor {\n    \t\tw, err := c.readRequest(ctx)\n    \t\tif c.r.remain != c.server.initialReadLimitSize() {\n    \t\t\t// If we read any bytes off the wire, we're active.\n    \t\t\tc.setState(c.rwc, StateActive)\n    \t\t}\n    \t\tif err != nil {\n    \t\t// 有删除，错误处理\n    \t\t}\n    \n    \t\t//有删除\n    \n    \t\t//前面都是建立连接，确认协议，设置连接状态等等等\n    \t\t//这里是真正处理请求的地方\n    \t\tserverHandler{c.server}.ServeHTTP(w, w.req)\n    \n    \t\tw.cancelCtx()\n    \t\tif c.hijacked() {\n    \t\t\treturn\n    \t\t}\n    \t\tw.finishRequest()\n    \t\t//有删除，关闭连接等操作\n    \t}\n    }\n\n再把serverHandler拎出来\n\n    type serverHandler struct {\n    \tsrv *Server\n    }\n    \n    func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    \thandler := sh.srv.Handler\n    \t//这里查询server是否设置过handle方法,如果没有,使用默认的DefaultServeMux,所以回过头去看第一行代码，是不是明白了为啥只传一个参数也可以呢？\n    \tif handler == nil {\n    \t\thandler = DefaultServeMux\n    \t}\n    \tif req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n    \t\thandler = globalOptionsHandler{}\n    \t}\n    \t//看这句\n    \thandler.ServeHTTP(rw, req)\n    }\n\n看到了吗，其实这么一长串调用下来，请求最终交给了Handle的ServeHTTP方法\n那么我们可以说，这个Handle其实扮演的就是路由的角色（是他将每一个请求分配到了对应的方法）\n\n这里啰嗦一下，这里的Handler是一个接口，只要我们实现了这个接口的方法就可以实现自己的路由\n\n那么首先，让我们来看看这个默认的handler的结构是怎么样的\n\n    type ServeMux struct {\n    \tmu    sync.RWMutex\n    \tm     map[string]muxEntry\n    \tes    []muxEntry // slice of entries sorted from longest to shortest. // 按照pattern的长度从长到短排列的\n    \thosts bool       // whether any patterns contain hostnames\n    }\n    \n    type muxEntry struct {\n    \th       Handler\n    \tpattern string\n    }\n    \n    // DefaultServeMux is the default ServeMux used by Serve.\n    var DefaultServeMux = &defaultServeMux\n    \n    var defaultServeMux ServeMux\n\n看它是怎么实现注册、分配路由的\n\n    //注册路由\n    func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    \tif handler == nil {\n    \t\tpanic(\"http: nil handler\")\n    \t}\n    \tmux.Handle(pattern, HandlerFunc(handler))\n    }\n    // 这个方法将普通的方法转换为了满足Handle接口的方法\n    type HandlerFunc func(ResponseWriter, *Request)\n    func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    \t//执行了自身\n    \tf(w, r)\n    }\n    \n    func (mux *ServeMux) Handle(pattern string, handler Handler) {\n    \tmux.mu.Lock()\n    \tdefer mux.mu.Unlock()\n    \n    \tif pattern == \"\" {\n    \t\tpanic(\"http: invalid pattern\")\n    \t}\n    \tif handler == nil {\n    \t\tpanic(\"http: nil handler\")\n    \t}\n    \tif _, exist := mux.m[pattern]; exist {\n    \t\tpanic(\"http: multiple registrations for \" + pattern)\n    \t}\n    \n    \tif mux.m == nil {\n    \t\tmux.m = make(map[string]muxEntry)\n    \t}\n    \t//存储到路由表里\n    \te := muxEntry{h: handler, pattern: pattern}\n    \tmux.m[pattern] = e\n    \tif pattern[len(pattern)-1] == '/' {\n    \t\tmux.es = appendSorted(mux.es, e)\n    \t}\n    \n    \tif pattern[0] != '/' {\n    \t\tmux.hosts = true\n    \t}\n    }\n    //分配路由\n    func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    \tif r.RequestURI == \"*\" {\n    \t\tif r.ProtoAtLeast(1, 1) {\n    \t\t\tw.Header().Set(\"Connection\", \"close\")\n    \t\t}\n    \t\tw.WriteHeader(StatusBadRequest)\n    \t\treturn\n    \t}\n    \th, _ := mux.Handler(r)\n    \t//处理\n    \th.ServeHTTP(w, r)\n    }\n    func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n    \n    \t//大段删除，都是处理字符串格式、判断的方法\n    \n    \treturn mux.handler(host, r.URL.Path)\n    }\n    \n    func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n    \tmux.mu.RLock()\n    \tdefer mux.mu.RUnlock()\n    \n    \t// Host-specific pattern takes precedence over generic ones\n    \t//寻找匹配的路由\n    \tif mux.hosts {\n    \t\th, pattern = mux.match(host + path)\n    \t}\n    \tif h == nil {\n    \t\th, pattern = mux.match(path)\n    \t}\n    \tif h == nil {\n    \t\th, pattern = NotFoundHandler(), \"\"\n    \t}\n    \treturn\n    }\n    func (mux *ServeMux) match(path string) (h Handler, pattern string) {\n    \t// Check for exact match first.\n    \tv, ok := mux.m[path]\n    \tif ok {\n    \t\treturn v.h, v.pattern\n    \t}\n    \n    \t// Check for longest valid match.  mux.es contains all patterns\n    \t// that end in / sorted from longest to shortest.\n    \tfor _, e := range mux.es {\n    \t\tif strings.HasPrefix(path, e.pattern) {\n    \t\t\treturn e.h, e.pattern\n    \t\t}\n    \t}\n    \treturn nil, \"\"\n    }\n\n使用默认的注册路由方法:\n\n    http.HandleFunc(\"/\", sayhelloName)\n\n方法的实现是:\n\n    func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    \tDefaultServeMux.HandleFunc(pattern, handler)\n    }\n\n参考资料:\n[build go web application](https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/03.3.html)\n[煎鱼博客](https://eddycjy.gitbook.io/golang/di-3-ke-gin)\n[http包源码分析](https://www.ulovecode.com/2019/09/03/Go/Golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)-net.http/)\n\n"}]